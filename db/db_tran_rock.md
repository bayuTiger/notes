# DBの基礎的な事柄2(演算・トランザクション・ロック)

以下の記事の続きです

[DBの基礎的な事柄1(データモデル〜SQL)](https://qiita.com/akitika/items/981674e7dc2954355738)

## 関係演算と集合演算

- 演算 = データベースから必要なデータを取り出すこと
- 関係演算 = テーブルから目的のデータを取り出すこと
  - 選択
    - 目的とするテーブルから選択条件を満たすレコードだけを取り出す
  - 射影
    - カラム名とその並びを指定することで、目的とするテーブルからその条件の通りの並びでレコードを取り出す
  - 結合
    - 指定される複数のテーブルの中で、共通のカラムを介してテーブルを結びつけ、新たな結果を取り出す
- 集合演算 = ２つのテーブルから集合の考えを利用してデータを取り出すこと
  - 和集合
    - ２つのテーブル全て
  - 差集合
    - ２つのテーブルの集合のうち、１つのテーブルのみに存在するもの
  - 積集合
    - ２つのテーブルに共通しているものだけ

## トランザクション

- 相互依存の関係にある複数の処理を１つに纏めることで、矛盾なく処理すること。
- またはdbを更新する単位。
- commitはトランザクション内の全ての変更を確定する処理
  - commitされるまでdbに値は反映されない
  - 一度commitしたトランザクションはrollbackできない
- rollbackはトランザクション内で行った更新の取り消しを行う
  - 取り消した後、トランザクションの開始前の状態に戻す

## 排他制御

- 複数のユーザーがデータを読み書きしても、矛盾が生じないようにする仕組み
- ロックを利用して実現する
  - 同一のデータに対して複数のトランザクションが同時に書き込むことを防止する仕組み

### ロック

#### ロックの種類

- 排他ロック
  - 他のトランザクションに対する読み書きを一切禁止する
- 共有ロック
  - 読みだけを許可する

#### ロックの仕組み

- 楽観的ロック(optimistic)
  - 複数のユーザーは参照や更新が可能
    - ただ最初に更新したユーザの処理が反映される
    - ほかのユーザーの更新は失敗or待ち状態
- 悲観的ロック(pessimistic)
  - 更新対象のデータを取得してから更新が完了するまでロックがかかる
    - 他のアクセスからは参照も更新もできない
  - 整合性は保ちやすいがパフォーマンスが低下する可能性がある
  - SQLで対応(SELECT ~ FOR UPDATE)

#### デッドロック

- 2人以上のユーザがお互いにロックを掛け合い、ロックの解除待ちになってしまう状態のこと
- エンジニアがdbに対して操作を行わないと、この状態を解消することはできない

#### デッドロックの回避策

- トランザクションを短くして、ロックをかける時間を短くする
- トランザクション内の処理の順番を決める

## 続き

[DBの基礎的な事柄3(正規化)](https://qiita.com/akitika/items/4e863c9443bfcfafae3f)
